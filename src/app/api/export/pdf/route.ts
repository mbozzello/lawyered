import { NextRequest, NextResponse } from "next/server";
import { getServerSession } from "next-auth";
import { authOptions } from "@/lib/auth";
import { prisma } from "@/lib/prisma";

export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  const { searchParams } = new URL(request.url);
  const contractId = searchParams.get("id");

  if (!contractId) {
    return NextResponse.json(
      { error: "Contract ID required" },
      { status: 400 }
    );
  }

  const userId = (session.user as { id: string }).id;

  const contract = await prisma.contract.findFirst({
    where: { id: contractId, userId },
    include: {
      clauses: { orderBy: { clauseNumber: "asc" } },
      summary: true,
    },
  });

  if (!contract || !contract.summary) {
    return NextResponse.json({ error: "Not found" }, { status: 404 });
  }

  // Generate a text-based report (simple but functional)
  const keyFindings = contract.summary.keyFindings as string[];
  const missingClauses = contract.summary.missingClauses as string[];

  let report = `LAWYERED â€” CONTRACT REVIEW REPORT\n`;
  report += `${"=".repeat(50)}\n\n`;
  report += `Document: ${contract.filename}\n`;
  report += `Contract Type: ${contract.contractType || "Unknown"}\n`;
  report += `Paper Type: ${contract.paperType === "internal" ? "Our Paper" : "External Paper"}\n`;
  report += `Review Date: ${new Date(contract.createdAt).toLocaleDateString("en-US", { year: "numeric", month: "long", day: "numeric" })}\n`;
  report += `Overall Risk: ${contract.summary.overallRisk.toUpperCase()}\n\n`;

  report += `EXECUTIVE SUMMARY\n`;
  report += `${"-".repeat(30)}\n`;
  report += `${contract.summary.executiveSummary}\n\n`;

  if (keyFindings.length > 0) {
    report += `KEY FINDINGS\n`;
    report += `${"-".repeat(30)}\n`;
    keyFindings.forEach((f, i) => {
      report += `${i + 1}. ${f}\n`;
    });
    report += `\n`;
  }

  if (missingClauses.length > 0) {
    report += `MISSING CLAUSES\n`;
    report += `${"-".repeat(30)}\n`;
    missingClauses.forEach((c, i) => {
      report += `${i + 1}. ${c}\n`;
    });
    report += `\n`;
  }

  report += `CLAUSE-BY-CLAUSE ANALYSIS\n`;
  report += `${"=".repeat(50)}\n\n`;

  contract.clauses.forEach((clause) => {
    const violations = clause.playbookViolations as { ruleName: string; severity: string; description: string }[];
    report += `Clause ${clause.clauseNumber}: ${clause.clauseType} [${clause.riskLevel.toUpperCase()} RISK]\n`;
    report += `${"-".repeat(40)}\n`;
    report += `${clause.explanation}\n`;

    if (violations.length > 0) {
      report += `\nPlaybook Violations:\n`;
      violations.forEach((v) => {
        report += `  [${v.severity.toUpperCase()}] ${v.ruleName}: ${v.description}\n`;
      });
    }

    if (clause.redlineSuggestion) {
      report += `\nSuggested Redline:\n`;
      report += `  ${clause.redlineSuggestion}\n`;
      if (clause.redlineExplanation) {
        report += `  Reason: ${clause.redlineExplanation}\n`;
      }
    }

    report += `\n`;
  });

  report += `\n${"=".repeat(50)}\n`;
  report += `Generated by Lawyered | Powered by Claude AI\n`;

  return new NextResponse(report, {
    headers: {
      "Content-Type": "text/plain; charset=utf-8",
      "Content-Disposition": `attachment; filename="${contract.filename.replace(/\.[^.]+$/, "")}-review.txt"`,
    },
  });
}
